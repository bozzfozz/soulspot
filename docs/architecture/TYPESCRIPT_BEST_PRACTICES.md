# TypeScript SoulSpot Best Practices Guide

> ğŸ¯ Comprehensive best practices for our Next.js 14 + tRPC + Prisma + BullMQ stack

---

## ğŸ“š Table of Contents

1. [Next.js 14 App Router](#1-nextjs-14-app-router)
2. [tRPC Integration](#2-trpc-integration)
3. [Prisma & PostgreSQL](#3-prisma--postgresql)
4. [BullMQ Workers](#4-bullmq-workers)
5. [Zod Validation](#5-zod-validation)
6. [React Query (TanStack Query)](#6-react-query-tanstack-query)
7. [Bun Runtime](#7-bun-runtime)
8. [Project Structure](#8-project-structure)
9. [Error Handling](#9-error-handling)
10. [Observability](#10-observability)

---

## 1. Next.js 14 App Router

### 1.1 File Conventions (CRITICAL!)

```
app/
â”œâ”€â”€ layout.tsx         # Root layout (REQUIRED) - wraps all pages
â”œâ”€â”€ page.tsx           # Route "/" 
â”œâ”€â”€ loading.tsx        # Loading UI (Suspense boundary)
â”œâ”€â”€ error.tsx          # Error boundary
â”œâ”€â”€ not-found.tsx      # 404 page
â”œâ”€â”€ api/
â”‚   â””â”€â”€ trpc/
â”‚       â””â”€â”€ [trpc]/
â”‚           â””â”€â”€ route.ts   # tRPC API handler
â”œâ”€â”€ (auth)/            # Route Group (no URL segment)
â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â””â”€â”€ page.tsx   # "/login"
â”‚   â””â”€â”€ register/
â”‚       â””â”€â”€ page.tsx   # "/register"
â”œâ”€â”€ library/
â”‚   â”œâ”€â”€ layout.tsx     # Nested layout for /library/*
â”‚   â”œâ”€â”€ page.tsx       # "/library"
â”‚   â””â”€â”€ [trackId]/
â”‚       â””â”€â”€ page.tsx   # "/library/abc123" (Dynamic)
â””â”€â”€ settings/
    â””â”€â”€ page.tsx       # "/settings"
```

### 1.2 Server vs Client Components

```typescript
// âœ… Server Component (default) - NO "use client"
// app/library/page.tsx
import { db } from "@/lib/db";

export default async function LibraryPage() {
  // Direct database access in Server Component
  const tracks = await db.track.findMany({
    take: 50,
    orderBy: { createdAt: "desc" },
  });

  return (
    <div>
      <h1>Your Library</h1>
      <TrackList tracks={tracks} />  {/* Pass data to Client Component */}
    </div>
  );
}

// âœ… Client Component - requires "use client"
// components/track-list.tsx
"use client";

import { useState } from "react";

export function TrackList({ tracks }: { tracks: Track[] }) {
  const [filter, setFilter] = useState("");
  
  // Client-side interactivity
  return (
    <input 
      value={filter} 
      onChange={(e) => setFilter(e.target.value)} 
    />
  );
}
```

### 1.3 Data Fetching Patterns

```typescript
// âœ… Server Component with async/await (PREFERRED)
async function ServerPage() {
  const data = await fetchData();  // Runs on server
  return <div>{data}</div>;
}

// âœ… Parallel data fetching
async function ParallelPage() {
  // Start all fetches simultaneously
  const [tracks, artists, playlists] = await Promise.all([
    db.track.findMany(),
    db.artist.findMany(),
    db.playlist.findMany(),
  ]);
  
  return <Dashboard tracks={tracks} artists={artists} playlists={playlists} />;
}

// âœ… Route Segment Config for caching
export const dynamic = "force-dynamic";  // Disable caching
export const revalidate = 60;            // Revalidate every 60 seconds
```

### 1.4 Route Props Helpers (Next.js 14+)

```typescript
// âœ… Use PageProps and LayoutProps helpers (generated by Next.js)
export default async function TrackPage(props: PageProps<"/library/[trackId]">) {
  const { trackId } = await props.params;
  const track = await db.track.findUnique({ where: { id: trackId } });
  return <TrackDetail track={track} />;
}

// With search params
export default async function SearchPage(props: PageProps<"/search">) {
  const { q, page } = await props.searchParams;
  // q = search query, page = pagination
}
```

### 1.5 Layouts Best Practices

```typescript
// app/layout.tsx - Root Layout
import { Inter } from "next/font/google";
import { TRPCProvider } from "@/lib/trpc/provider";

const inter = Inter({ subsets: ["latin"] });

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <TRPCProvider>
          {children}
        </TRPCProvider>
      </body>
    </html>
  );
}

// âœ… Nested layout for specific routes
// app/library/layout.tsx
export default function LibraryLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex">
      <LibrarySidebar />
      <main className="flex-1">{children}</main>
    </div>
  );
}
```

---

## 2. tRPC Integration

### 2.1 Router Structure

```typescript
// lib/trpc/routers/index.ts
import { router } from "../trpc";
import { trackRouter } from "./track";
import { artistRouter } from "./artist";
import { playlistRouter } from "./playlist";
import { downloadRouter } from "./download";
import { spotifyRouter } from "./spotify";
import { settingsRouter } from "./settings";

export const appRouter = router({
  track: trackRouter,
  artist: artistRouter,
  playlist: playlistRouter,
  download: downloadRouter,
  spotify: spotifyRouter,
  settings: settingsRouter,
});

export type AppRouter = typeof appRouter;
```

### 2.2 Procedure Definitions

```typescript
// lib/trpc/routers/track.ts
import { z } from "zod";
import { router, publicProcedure, protectedProcedure } from "../trpc";
import { db } from "@/lib/db";
import { TRPCError } from "@trpc/server";

// âœ… Define input schemas with Zod
const trackSearchInput = z.object({
  query: z.string().min(1).max(200),
  page: z.number().int().positive().default(1),
  limit: z.number().int().min(1).max(100).default(20),
});

export const trackRouter = router({
  // âœ… Query for reading data
  search: publicProcedure
    .input(trackSearchInput)
    .query(async ({ input }) => {
      const { query, page, limit } = input;
      const skip = (page - 1) * limit;

      const [tracks, total] = await Promise.all([
        db.track.findMany({
          where: {
            OR: [
              { title: { contains: query, mode: "insensitive" } },
              { artist: { contains: query, mode: "insensitive" } },
            ],
          },
          skip,
          take: limit,
          orderBy: { relevanceScore: "desc" },
        }),
        db.track.count({
          where: {
            OR: [
              { title: { contains: query, mode: "insensitive" } },
              { artist: { contains: query, mode: "insensitive" } },
            ],
          },
        }),
      ]);

      return {
        tracks,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      };
    }),

  // âœ… Mutation for writing data
  addToLibrary: protectedProcedure
    .input(z.object({ trackId: z.string().uuid() }))
    .mutation(async ({ input, ctx }) => {
      const track = await db.track.findUnique({
        where: { id: input.trackId },
      });

      if (!track) {
        throw new TRPCError({
          code: "NOT_FOUND",
          message: "Track not found",
        });
      }

      return db.libraryTrack.create({
        data: {
          userId: ctx.userId,
          trackId: input.trackId,
        },
      });
    }),
});
```

### 2.3 Client Usage (React Query Integration)

```typescript
// âœ… In Client Components
"use client";

import { trpc } from "@/lib/trpc/client";

export function SearchResults({ query }: { query: string }) {
  // useQuery for reading
  const { data, isLoading, error } = trpc.track.search.useQuery({
    query,
    page: 1,
    limit: 20,
  });

  // useMutation for writing
  const addToLibrary = trpc.track.addToLibrary.useMutation({
    onSuccess: () => {
      // Invalidate queries to refresh data
      utils.track.search.invalidate();
    },
  });

  const utils = trpc.useUtils();

  if (isLoading) return <Skeleton />;
  if (error) return <Error message={error.message} />;

  return (
    <ul>
      {data?.tracks.map((track) => (
        <li key={track.id}>
          {track.title}
          <button onClick={() => addToLibrary.mutate({ trackId: track.id })}>
            Add to Library
          </button>
        </li>
      ))}
    </ul>
  );
}
```

### 2.4 Server-Side tRPC Calls

```typescript
// âœ… In Server Components - use createCaller
import { createCaller } from "@/lib/trpc/server";

export default async function LibraryPage() {
  const trpc = createCaller();
  
  // Direct server-side call (no HTTP roundtrip)
  const result = await trpc.track.search({ 
    query: "favorite", 
    page: 1 
  });

  return <TrackList tracks={result.tracks} />;
}
```

---

## 3. Prisma & PostgreSQL

### 3.1 Schema Best Practices

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// âœ… Use meaningful names, not abbreviations
model Track {
  id            String   @id @default(uuid())
  title         String
  artist        String
  album         String?
  duration      Int      // Duration in seconds
  isrc          String?  @unique
  spotifyUri    String?  @unique
  deezerUri     String?  @unique
  
  // âœ… Always add timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // âœ… Relations
  libraryTracks LibraryTrack[]
  downloads     Download[]
  
  // âœ… Indexes for common queries
  @@index([title, artist])
  @@index([createdAt])
  @@map("tracks")  // Explicit table name
}

model Download {
  id            String         @id @default(uuid())
  trackId       String
  track         Track          @relation(fields: [trackId], references: [id], onDelete: Cascade)
  
  status        DownloadStatus @default(PENDING)
  progress      Int            @default(0)
  quality       String         @default("FLAC")
  filePath      String?
  
  // âœ… Retry handling
  retryCount    Int            @default(0)
  lastError     String?
  
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  
  @@index([status])
  @@index([trackId])
  @@map("downloads")
}

enum DownloadStatus {
  PENDING
  DOWNLOADING
  PROCESSING
  COMPLETED
  FAILED
}
```

### 3.2 Connection Pooling (CRITICAL for Production!)

```typescript
// lib/db.ts
import { PrismaClient } from "@prisma/client";

// âœ… Singleton pattern for PrismaClient
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const db =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: process.env.NODE_ENV === "development" 
      ? ["query", "error", "warn"] 
      : ["error"],
  });

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prisma = db;
}

// âœ… Connection URL with pool settings
// DATABASE_URL="postgresql://user:pass@host:5432/db?connection_limit=20&pool_timeout=10"
```

### 3.3 Query Optimization

```typescript
// âœ… Select only needed fields
const tracks = await db.track.findMany({
  select: {
    id: true,
    title: true,
    artist: true,
    // Don't select large fields unless needed
  },
});

// âœ… Use pagination ALWAYS
const tracks = await db.track.findMany({
  take: 50,
  skip: (page - 1) * 50,
  orderBy: { createdAt: "desc" },
});

// âœ… Batch operations with transactions
await db.$transaction([
  db.track.updateMany({
    where: { playlistId },
    data: { updatedAt: new Date() },
  }),
  db.playlist.update({
    where: { id: playlistId },
    data: { trackCount: { increment: 1 } },
  }),
]);

// âœ… Upsert for idempotent operations
await db.track.upsert({
  where: { spotifyUri },
  create: { title, artist, spotifyUri },
  update: { title, artist },
});
```

### 3.4 Relations & Includes

```typescript
// âœ… Include related data when needed
const playlist = await db.playlist.findUnique({
  where: { id },
  include: {
    tracks: {
      take: 50,
      orderBy: { position: "asc" },
      include: {
        track: true,  // Nested include
      },
    },
    _count: {
      select: { tracks: true },  // Count without fetching
    },
  },
});

// âŒ Avoid N+1 queries
const tracks = await db.track.findMany();
for (const track of tracks) {
  // âŒ This creates N additional queries!
  const downloads = await db.download.findMany({
    where: { trackId: track.id },
  });
}

// âœ… Use include or separate query with IN
const tracks = await db.track.findMany({
  include: { downloads: true },  // Single query
});
```

---

## 4. BullMQ Workers

### 4.1 Queue Setup

```typescript
// lib/queue/queues.ts
import { Queue, Worker, QueueEvents } from "bullmq";
import IORedis from "ioredis";

// âœ… Shared connection with proper settings
const connection = new IORedis(process.env.REDIS_URL!, {
  maxRetriesPerRequest: null,  // REQUIRED for BullMQ workers
});

// âœ… Queue definitions
export const downloadQueue = new Queue("download", {
  connection,
  defaultJobOptions: {
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 1000,  // 1s, 2s, 4s
    },
    removeOnComplete: 1000,  // Keep last 1000 completed
    removeOnFail: 5000,      // Keep last 5000 failed
  },
});

export const syncQueue = new Queue("sync", {
  connection,
  defaultJobOptions: {
    attempts: 5,
    backoff: {
      type: "exponential",
      delay: 5000,
    },
  },
});
```

### 4.2 Worker Implementation

```typescript
// workers/download.worker.ts
import { Worker, Job } from "bullmq";
import { db } from "@/lib/db";
import { downloadTrack } from "@/lib/slskd";
import { logger } from "@/lib/logger";

interface DownloadJob {
  trackId: string;
  quality: "FLAC" | "MP3_320" | "MP3_256";
}

const worker = new Worker<DownloadJob>(
  "download",
  async (job: Job<DownloadJob>) => {
    const { trackId, quality } = job.data;

    // âœ… Update status at start
    await db.download.update({
      where: { trackId },
      data: { status: "DOWNLOADING" },
    });

    try {
      // âœ… Report progress
      const result = await downloadTrack(trackId, quality, (progress) => {
        job.updateProgress(progress);
      });

      // âœ… Update on success
      await db.download.update({
        where: { trackId },
        data: {
          status: "COMPLETED",
          progress: 100,
          filePath: result.filePath,
        },
      });

      return { success: true, filePath: result.filePath };
    } catch (error) {
      // âœ… Update on failure
      await db.download.update({
        where: { trackId },
        data: {
          status: "FAILED",
          lastError: error instanceof Error ? error.message : "Unknown error",
          retryCount: { increment: 1 },
        },
      });

      throw error;  // Let BullMQ handle retry
    }
  },
  {
    connection,
    concurrency: 5,           // Process 5 jobs at once
    limiter: {
      max: 10,                // Max 10 jobs
      duration: 1000,         // Per second (rate limiting)
    },
  }
);

// âœ… Event handlers
worker.on("completed", (job) => {
  logger.info({ jobId: job.id }, "Download completed");
});

worker.on("failed", (job, error) => {
  logger.error({ jobId: job?.id, error: error.message }, "Download failed");
});

worker.on("progress", (job, progress) => {
  logger.debug({ jobId: job.id, progress }, "Download progress");
});

export default worker;
```

### 4.3 Adding Jobs

```typescript
// lib/queue/jobs.ts
import { downloadQueue, syncQueue } from "./queues";

export async function addDownloadJob(
  trackId: string,
  quality: string,
  priority?: number
) {
  return downloadQueue.add(
    "download-track",  // Job name
    { trackId, quality },
    {
      priority,        // Lower = higher priority
      jobId: trackId,  // Deduplicate by trackId
    }
  );
}

export async function addSyncJob(playlistId: string) {
  return syncQueue.add(
    "sync-playlist",
    { playlistId },
    {
      repeat: {
        pattern: "0 * * * *",  // Every hour
      },
    }
  );
}

// âœ… Bulk add for efficiency
export async function addBulkDownloads(
  tracks: Array<{ trackId: string; quality: string }>
) {
  return downloadQueue.addBulk(
    tracks.map((t, index) => ({
      name: "download-track",
      data: t,
      opts: { priority: index },  // Process in order
    }))
  );
}
```

---

## 5. Zod Validation

### 5.1 Schema Definition Patterns

```typescript
// lib/schemas/track.ts
import { z } from "zod";

// âœ… Base schema
export const trackSchema = z.object({
  id: z.string().uuid(),
  title: z.string().min(1).max(500),
  artist: z.string().min(1).max(500),
  album: z.string().max(500).optional(),
  duration: z.number().int().positive(),
  isrc: z.string().regex(/^[A-Z]{2}[A-Z0-9]{3}\d{7}$/).optional(),
  spotifyUri: z.string().startsWith("spotify:track:").optional(),
  createdAt: z.date(),
  updatedAt: z.date(),
});

// âœ… Input schemas (what client sends)
export const trackCreateInput = trackSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const trackUpdateInput = trackCreateInput.partial();

// âœ… Query/Filter schemas
export const trackQuerySchema = z.object({
  query: z.string().optional(),
  artist: z.string().optional(),
  album: z.string().optional(),
  page: z.coerce.number().int().positive().default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  sortBy: z.enum(["title", "artist", "createdAt"]).default("createdAt"),
  sortOrder: z.enum(["asc", "desc"]).default("desc"),
});

// âœ… Type inference
export type Track = z.infer<typeof trackSchema>;
export type TrackCreateInput = z.infer<typeof trackCreateInput>;
export type TrackQuery = z.infer<typeof trackQuerySchema>;
```

### 5.2 Custom Validators

```typescript
// lib/schemas/validators.ts
import { z } from "zod";

// âœ… Reusable custom refinements
export const spotifyUri = z.string().refine(
  (val) => /^spotify:(track|album|artist|playlist):[\w]+$/.test(val),
  { message: "Invalid Spotify URI format" }
);

export const deezerUri = z.string().refine(
  (val) => /^deezer:(track|album|artist):[\d]+$/.test(val),
  { message: "Invalid Deezer URI format" }
);

// âœ… Transform during validation
export const paginationSchema = z.object({
  page: z.string().transform(Number).pipe(z.number().int().positive()),
  limit: z.string().transform(Number).pipe(z.number().int().min(1).max(100)),
});

// âœ… Union types for flexibility
export const musicUri = z.union([spotifyUri, deezerUri]);

// âœ… Discriminated unions
export const downloadJobSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("track"),
    trackId: z.string().uuid(),
    quality: z.enum(["FLAC", "MP3_320", "MP3_256"]),
  }),
  z.object({
    type: z.literal("album"),
    albumId: z.string().uuid(),
    quality: z.enum(["FLAC", "MP3_320", "MP3_256"]),
  }),
]);
```

### 5.3 Error Handling

```typescript
// lib/schemas/errors.ts
import { z } from "zod";

// âœ… Custom error messages
const trackInput = z.object({
  title: z.string({
    required_error: "Title is required",
    invalid_type_error: "Title must be a string",
  }).min(1, "Title cannot be empty").max(500, "Title too long"),
});

// âœ… Parse with error formatting
export function parseTrackInput(data: unknown) {
  const result = trackInput.safeParse(data);
  
  if (!result.success) {
    const errors = result.error.flatten();
    return {
      success: false,
      errors: errors.fieldErrors,
    };
  }
  
  return {
    success: true,
    data: result.data,
  };
}
```

---

## 6. React Query (TanStack Query)

### 6.1 Query Keys Convention

```typescript
// lib/query-keys.ts
export const queryKeys = {
  tracks: {
    all: ["tracks"] as const,
    list: (filters: TrackQuery) => ["tracks", "list", filters] as const,
    detail: (id: string) => ["tracks", "detail", id] as const,
  },
  playlists: {
    all: ["playlists"] as const,
    list: () => ["playlists", "list"] as const,
    detail: (id: string) => ["playlists", "detail", id] as const,
    tracks: (id: string) => ["playlists", id, "tracks"] as const,
  },
  downloads: {
    all: ["downloads"] as const,
    active: () => ["downloads", "active"] as const,
  },
};
```

### 6.2 Query Options

```typescript
// âœ… Important defaults to know
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 0,           // Data is immediately stale
      gcTime: 5 * 60 * 1000,  // 5 min garbage collection (was cacheTime)
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
      retry: 3,
    },
  },
});

// âœ… Per-query options
const { data } = useQuery({
  queryKey: queryKeys.tracks.list(filters),
  queryFn: () => fetchTracks(filters),
  staleTime: 60 * 1000,      // Fresh for 1 minute
  gcTime: 10 * 60 * 1000,    // Keep in cache for 10 minutes
  refetchInterval: 30000,    // Refetch every 30s (for real-time data)
});
```

### 6.3 Mutations with Optimistic Updates

```typescript
"use client";

import { trpc } from "@/lib/trpc/client";

export function useAddToLibrary() {
  const utils = trpc.useUtils();

  return trpc.track.addToLibrary.useMutation({
    // âœ… Optimistic update
    onMutate: async (newTrack) => {
      // Cancel outgoing refetches
      await utils.track.library.cancel();

      // Snapshot previous value
      const previousTracks = utils.track.library.getData();

      // Optimistically update
      utils.track.library.setData(undefined, (old) => {
        if (!old) return [newTrack];
        return [...old, newTrack];
      });

      // Return context with snapshot
      return { previousTracks };
    },

    // âœ… Rollback on error
    onError: (err, newTrack, context) => {
      utils.track.library.setData(undefined, context?.previousTracks);
    },

    // âœ… Always refetch after mutation
    onSettled: () => {
      utils.track.library.invalidate();
    },
  });
}
```

---

## 7. Bun Runtime

### 7.1 Why Bun?

```markdown
| Feature          | Node.js  | Bun      |
|------------------|----------|----------|
| Startup time     | ~30ms    | ~6ms     |
| Install speed    | 1x       | 30x      |
| TypeScript       | Need tsc | Native   |
| Test runner      | Jest     | Built-in |
| Bundler          | Webpack  | Built-in |
```

### 7.2 Bun Configuration

```typescript
// bunfig.toml
[install]
# Save exact versions
save-exact = true

[run]
# Enable auto-reload in development
watch = true

# Source maps for debugging
sourcemap = "inline"
```

### 7.3 Package Scripts

```json
// package.json
{
  "scripts": {
    "dev": "bun run --watch src/index.ts",
    "build": "bun build src/index.ts --outdir dist",
    "start": "bun run dist/index.js",
    "test": "bun test",
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio"
  }
}
```

### 7.4 Node.js Compatibility

```typescript
// âœ… Most Node.js APIs work
import { readFile, writeFile } from "fs/promises";
import { join } from "path";
import { createHash } from "crypto";

// âœ… Built-in fetch (no node-fetch needed)
const response = await fetch("https://api.example.com/data");

// âœ… Native Bun APIs (faster alternatives)
const file = Bun.file("./data.json");
const content = await file.text();

// âœ… Bun's built-in SQLite (if needed)
import { Database } from "bun:sqlite";
```

---

## 8. Project Structure

```
soulspot-ts/
â”œâ”€â”€ app/                          # Next.js App Router
â”‚   â”œâ”€â”€ layout.tsx                # Root layout
â”‚   â”œâ”€â”€ page.tsx                  # Home page
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ trpc/[trpc]/route.ts  # tRPC handler
â”‚   â”œâ”€â”€ (auth)/
â”‚   â”‚   â”œâ”€â”€ login/page.tsx
â”‚   â”‚   â””â”€â”€ register/page.tsx
â”‚   â”œâ”€â”€ library/
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ [trackId]/page.tsx
â”‚   â”œâ”€â”€ downloads/page.tsx
â”‚   â”œâ”€â”€ playlists/
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ [playlistId]/page.tsx
â”‚   â””â”€â”€ settings/page.tsx
â”‚
â”œâ”€â”€ components/                   # React components
â”‚   â”œâ”€â”€ ui/                       # shadcn/ui components
â”‚   â”‚   â”œâ”€â”€ button.tsx
â”‚   â”‚   â”œâ”€â”€ dialog.tsx
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ layout/                   # Layout components
â”‚   â”‚   â”œâ”€â”€ header.tsx
â”‚   â”‚   â”œâ”€â”€ sidebar.tsx
â”‚   â”‚   â””â”€â”€ footer.tsx
â”‚   â”œâ”€â”€ tracks/                   # Feature components
â”‚   â”‚   â”œâ”€â”€ track-card.tsx
â”‚   â”‚   â”œâ”€â”€ track-list.tsx
â”‚   â”‚   â””â”€â”€ track-actions.tsx
â”‚   â””â”€â”€ providers/                # Context providers
â”‚       â””â”€â”€ theme-provider.tsx
â”‚
â”œâ”€â”€ lib/                          # Shared utilities
â”‚   â”œâ”€â”€ db.ts                     # Prisma client
â”‚   â”œâ”€â”€ trpc/
â”‚   â”‚   â”œâ”€â”€ trpc.ts               # tRPC init
â”‚   â”‚   â”œâ”€â”€ client.ts             # tRPC client
â”‚   â”‚   â”œâ”€â”€ server.ts             # Server caller
â”‚   â”‚   â””â”€â”€ routers/
â”‚   â”‚       â”œâ”€â”€ index.ts
â”‚   â”‚       â”œâ”€â”€ track.ts
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ queue/
â”‚   â”‚   â”œâ”€â”€ queues.ts             # BullMQ queues
â”‚   â”‚   â””â”€â”€ jobs.ts               # Job definitions
â”‚   â”œâ”€â”€ schemas/                  # Zod schemas
â”‚   â”‚   â”œâ”€â”€ track.ts
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ providers/                # External API clients
â”‚   â”‚   â”œâ”€â”€ spotify.ts
â”‚   â”‚   â”œâ”€â”€ deezer.ts
â”‚   â”‚   â””â”€â”€ slskd.ts
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ logger.ts
â”‚       â””â”€â”€ helpers.ts
â”‚
â”œâ”€â”€ workers/                      # BullMQ workers
â”‚   â”œâ”€â”€ download.worker.ts
â”‚   â”œâ”€â”€ sync.worker.ts
â”‚   â””â”€â”€ index.ts                  # Worker entry
â”‚
â”œâ”€â”€ prisma/
â”‚   â”œâ”€â”€ schema.prisma             # Database schema
â”‚   â””â”€â”€ migrations/               # DB migrations
â”‚
â”œâ”€â”€ public/                       # Static files
â”‚
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile
â”‚   â””â”€â”€ docker-compose.yml
â”‚
â”œâ”€â”€ .env.example
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ next.config.js
â””â”€â”€ tailwind.config.js
```

---

## 9. Error Handling

### 9.1 tRPC Error Handling

```typescript
// lib/trpc/errors.ts
import { TRPCError } from "@trpc/server";

// âœ… Custom error class
export class AppError extends TRPCError {
  constructor(
    code: TRPCError["code"],
    message: string,
    public details?: Record<string, unknown>
  ) {
    super({ code, message });
  }
}

// âœ… Error factory functions
export const notFound = (resource: string) =>
  new AppError("NOT_FOUND", `${resource} not found`);

export const unauthorized = (message = "Unauthorized") =>
  new AppError("UNAUTHORIZED", message);

export const badRequest = (message: string, details?: Record<string, unknown>) =>
  new AppError("BAD_REQUEST", message, details);
```

### 9.2 Global Error Handler

```typescript
// app/error.tsx
"use client";

import { useEffect } from "react";
import { Button } from "@/components/ui/button";

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log to error tracking service
    console.error(error);
  }, [error]);

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h2 className="text-2xl font-bold mb-4">Something went wrong!</h2>
      <p className="text-gray-600 mb-4">{error.message}</p>
      <Button onClick={reset}>Try again</Button>
    </div>
  );
}
```

---

## 10. Observability

### 10.1 Structured Logging

```typescript
// lib/utils/logger.ts
import pino from "pino";

export const logger = pino({
  level: process.env.LOG_LEVEL || "info",
  transport:
    process.env.NODE_ENV === "development"
      ? { target: "pino-pretty" }
      : undefined,
  base: {
    service: "soulspot",
    env: process.env.NODE_ENV,
  },
});

// âœ… Usage
logger.info({ trackId, artist, title }, "Track added to library");
logger.error({ error, jobId }, "Download failed");
logger.warn({ userId, action }, "Rate limit exceeded");
```

### 10.2 Health Checks

```typescript
// app/api/health/route.ts
import { db } from "@/lib/db";
import { NextResponse } from "next/server";

export async function GET() {
  try {
    // Check database
    await db.$queryRaw`SELECT 1`;

    // Check Redis (BullMQ)
    // await redisClient.ping();

    return NextResponse.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      services: {
        database: "up",
        redis: "up",
      },
    });
  } catch (error) {
    return NextResponse.json(
      {
        status: "unhealthy",
        error: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 503 }
    );
  }
}
```

### 10.3 Performance Monitoring

```typescript
// lib/utils/timing.ts
export function withTiming<T>(
  name: string,
  fn: () => Promise<T>
): Promise<T> {
  const start = performance.now();
  return fn().finally(() => {
    const duration = performance.now() - start;
    logger.debug({ name, duration: `${duration.toFixed(2)}ms` }, "Timing");
  });
}

// âœ… Usage
const tracks = await withTiming("db.track.findMany", () =>
  db.track.findMany({ take: 100 })
);
```

---

## ğŸ“‹ Quick Reference Checklist

### Before Starting a Feature:

- [ ] Define Zod schema for input validation
- [ ] Check if tRPC procedure exists or needs creation
- [ ] Identify Server vs Client Component needs
- [ ] Plan database queries (avoid N+1!)
- [ ] Consider caching strategy

### Before Committing:

- [ ] TypeScript compiles without errors (`bun tsc`)
- [ ] All Zod schemas have proper error messages
- [ ] Database queries use proper indexes
- [ ] Client components have "use client" directive
- [ ] Server components don't use hooks
- [ ] Error boundaries are in place

### Production Readiness:

- [ ] Environment variables documented
- [ ] Database connection pooling configured
- [ ] BullMQ workers have proper retry logic
- [ ] Health check endpoint exists
- [ ] Logging is structured (JSON)
- [ ] Error tracking configured

---

> ğŸ“– **Sources:**
> - [Next.js Docs](https://nextjs.org/docs)
> - [tRPC Docs](https://trpc.io/docs)
> - [Prisma Docs](https://www.prisma.io/docs)
> - [BullMQ Docs](https://docs.bullmq.io)
> - [Zod Docs](https://zod.dev)
> - [TanStack Query Docs](https://tanstack.com/query/latest)
> - [Bun Docs](https://bun.sh/docs)
